using UnityEngine;
using Infra;
using Infra.Collections;

namespace BatCave.Terrain {
/// <summary>
/// Rasterizing the terrain based on the points held by the game (those were
/// generated by the TerrainGenerator).
/// </summary>
public class TerrainRasterizer : MonoSingleton<TerrainRasterizer> {
    public float floorY = -2.2f;
    public float ceilingY = 2.2f;
	public Spline.ContinuousSpline spline;
    public GameObjectPool terrainPool;

    /// <summary>
    /// Creates the next terrain chunk (floor and ceiling).
    /// </summary>
    /// <param name="lastPointIndex">The index of the last point that was rasterized.</param>
    /// <returns>The index of the last point used in the rasterized chunk. If
    /// there are not enough points to rasterize the next chunk, returns the
    /// 'lastPointIndex' given.</returns>
    public static int RasterizeNextChunk(int lastPointIndex) {
        return instance._RasterizeNextChunk(lastPointIndex);
    }

    private int _RasterizeNextChunk(int lastPointIndex) {
        DebugUtils.Assert(lastPointIndex < Game.instance.terrainPoints.Count, "Last point index out of bounds");
        var startPoint = Game.instance.terrainPoints[lastPointIndex];
        if (lastPointIndex + 2 >= Game.instance.terrainPoints.Count) {
            DebugUtils.Log("Not enough points to rasterize");
            return lastPointIndex;
        }
        var endPoint = Game.instance.terrainPoints[lastPointIndex + 1];
        var nextPoint = Game.instance.terrainPoints[lastPointIndex + 2];

        // Create ceiling points.
        var ceilingPoints = GetPoints(true, startPoint, endPoint, nextPoint);
        var floorPoints = GetPoints(false, startPoint, endPoint, nextPoint);

        var chunk = terrainPool.Borrow<TerrainChunk>(ceilingPoints, floorPoints);
        DebugUtils.Log("Rasterized chunk " + chunk.name);
        return lastPointIndex + 1;
    }

    private Vector2[] GetPoints(bool isCeiling, params TerrainGenerator.TerrainPoint[] terrainPoints) {
        int index = 0;
        var startPoint = terrainPoints[index++];
        var endPoint = terrainPoints[index++];
        var nextPoint = terrainPoints[index++];

        float baseY = isCeiling ? ceilingY : floorY;

        // Create rasterized points.
        var points = new Vector2[10];
        index = 0;
        // Create flat edge at the base.
        points[index].x = endPoint.x;
        points[index++].y = baseY;
        points[index].x = startPoint.x;
        points[index++].y = baseY;
        // Go up to the start point.
        points[index].x = startPoint.x;
        points[index++].y = startPoint.GetY(isCeiling);

        // EXERCISE: Implement cubic spline interpolation.
			int amountOfPoints = 6;
			Vector2[] splinePoints = new Vector2[2];
			splinePoints [0].x = startPoint.x;
			splinePoints [0].y = startPoint.GetY(isCeiling);
			splinePoints [1].x = startPoint.x;
			splinePoints [2].y = startPoint.GetY(isCeiling);
			spline = new Spline.ContinuousSpline (splinePoints);
			Vector2 next;
			next.x = nextPoint.x;
			next.y = nextPoint.GetY (isCeiling);
			spline.AddControlPoints(next);
			float delta_X = (endPoint.x - startPoint.x) / (amountOfPoints - 1);
			int i;
			for (i = 1; i < amountOfPoints; i++) {
				points[index].x = startPoint.x+(i*delta_X);
				points[index++].y = spline.Value(startPoint.x+(i*delta_X));
			}
			index = index+i;
        // Finish with the end point.
        points[index].x = endPoint.x;
        points[index++].y = endPoint.GetY(isCeiling);
        return points;
    }
}
}
